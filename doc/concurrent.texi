\input texinfo @c -*-coding: mule-utf-8-unix; fill-column: 58-*-
@setfilename concurrent.info

@c @documentlanguage ru
@documentencoding UTF-8

@node Top, , (dir), (dir)

Описание библиотеки Concurrent.*

Данная библиотека создана, в первую очередь, для
упорядочения работы с большим количеством активных
@footnote{Под активной сущностью понимается либо объект,
способный принимать нить (поток) управления (задача), либо
объект, несущий состояние и методы взаимодействия с
сущностью и участвующий в ните управления как
олицетворение сущности, как например оюъекты,
олицетворяющие трейдеров в программе stress_run, которые
не имеют собственной нити управления, но управляются
объектами Worker.} сущностей на языке Ада. Активность
сущности не является необходимым условием использования
данной библиотеки.

В библиотеке можно выделить несколько
функциональных ядер:

@enumerate 
@item 

Объектные хранилища (repositories). Благодаря сделанным
абстракциям все экземпляры определенного типа объектов
хранятся, как бы, в одном месте - хранилище. Это
достигается разделением объектов и их видимостей
(views). Видимость объекта - это тип переменной в
программе на Аде, имеющей тот же набор операций, что и сам
объект, однако являющийся только "умной ссылкой" на
объект, всегда находящийся в хранилище. Такой подход
позволил, во-первых, контролировать создание/удаление
сущностей, имеющих, по своей семантике, глобальную
привязку (трейдер Вася всегда один, независимо от того, в
скольких местах программы создается его
видимость). Во-вторых, регистрация всех экземпляров типа в
одном месте позволяет обозревать все экземпляры типа (всех
трейдеров, с которыми мы работаем) из одного места.

* Между типом объекта и хранилищем - взаимно однозначное соответствие*

* Отвязка существования объектов от структуры потока
управления программы. Объект создается в хранилище (или
ищется в нем) а в нужном месте программы (области
деклараций) создается видимость на него *

* Идентификация объекта в пределах одного хранилища и
  глобально *

@item

Видимости. В нормальном состоянии всегда связаны с
какими-либо объектами из хранилища. Делятся по типам на
одиночные (Singular) - ссылаются на один объект и
множественные (Plural) - ссылаются на множество объектов
как на одно целое.

@item

Реестры (registries) или каталоги.  В простейшем случае,
каталог - это перечень информационных записей об объектах
из одного или нескольких хранилищ, как уже в нем
существующих так и предназначенных для создания.

Информационные записи деляться на шаблоны - по ним идет
создание объектов - и записи, которые описывают уже
существующие объекты. Логически они разделены и находятся
в разных каталогах.

* Записи об одном объекте и о семействе *

* Связь информационной записи и видимости на объект
  (не определена) *

* Связь информационной записи и объекта (по одной записи -
шаблону может быть создано множество объектов с _одним и
только одним_ исходным состоянием (создание через Plural
виды?)). *

* Связь видимости и типа объекта - поскольку видимость
полностью повторяет интерфейс объекта не может быть одной
видимости для разных типов объекта. Не существует понятия
``суженной видимости'' (как если бы мы хотели с помощью
видимости, предназначенной для родительского класса
работать с дочерним), поскольку видимость управляет также
созданием объекта. *

* Связь видимости и хранилища - исходя из предыдущего - не
может быть одной видимости, участвующей в различных
хранилищах, но для каждого хранилища свой набор
видимостей, различающихся типом (Singular, Plural). 

<NB> Множественные видимости ссылаются на объекты в том же
хранилище, что и одиночные - иначе бы взятие Sub_View было
бы не возможно. *

@item

Контейнеры с различными видами паралельного доступа.

@item 

Абстракции синхронизации доступа для теговых типов.

@end enumerate

------ Пакеты ----------

@itemize
@item

Concurrent - корень библиотеки.

@item

Concurrent.Containers - Контейнеры с параллельным
доступом.

@item

Concurrent.Concurrent_Accessibles - Абстракция тегового
типа с параллельным доступом.  Реализует модель "несколько
читателей - один писатель".

@item

Concurrent.Counters - Счетчики 

@item

Concurrent.Counters.One_Cell_Memory_Counter -
последовательно возрастающий счетчик, который может
запомнить произвольное значение в дополнительную ячейку
памяти и сравнивать свое текущее значение с
запомненным. Т. о. можно всегда иметь два текущих значения
счета - с самого начала (глобальное) и относительно
какого-то момента времени.

@item

Concurrent.Info_Types - Абстрактный тип информационной
записи об объекте.

@item 

Concurrent.Object_Descriptors - Вспомогательный тип
Object_Descriptor_Type для построения разного рода видов и
хранилищ.

@item

Concurrent.Object_Types - Абстрактный тип объекта.  Все
объекты - элементы контейнеров с параллельным доступом
должны наследоваться от этого типа.

@item

<<<<<<< concurrent.texi
---
@end itemize

------------ Примеры -------------------------

Первый шаг - создать интерфейс своего объекта.
(my_objects.ads, шаг 1).

Шаг 2 - создать информационную запись для описания
создания объекта.

Шаг 3 - создать тип идентификатора шаблона в каталоге
шаблонов.

Шаг 4 - описать тип каталога шаблонов объектов.

Шаг 5 - создать тип идентификатора объекта в хранилище.

Шаг 6 - создать тип дескриптора объекта, определить
функцию No_More_Refs.

Шаг 7 - описать тип хранилища объектов.

Шаг 8 - инстанциировать пакет Concurrent.Object_Holders.

Шаг 9 - породить тип холдера, подмешав интерфейс
объекта. Реализовать интерфейс как делегации
внутр. объекту.

Шаг ? - создать шаблон в каталоге

Шаг ? - Создать видимость, указав в кач. дискриминанта
идентификатор шаблона.

@itemize

@item
one_object_and_view.adb -  Создание одиночного объекта и его первого вида.

@end itemize

@bye
=======
---
@end itemize

------------ Примеры -------------------------

Первый шаг - создать интерфейс своего объекта.
(my_objects.ads, шаг 1).

Шаг 2 - определить тип шаблона как наследника от
Concurrent.Info_Types.Info_Type, определить отображения на
теги объектов (функция New_Object_Tag).

Шаг 3 - опрелелить тип идентификатора шаблона (как type
... is new ...), нулевое значение для данного типа, хэш
функцию отображения на Ada.Containers.Hash_Type.

Шаг 4 - опрелелить тип идентификатора объекта (как type
... is new ...), нулевое значение для данного типа, хэш
функцию отображения на Ada.Containers.Hash_Type.

Шаг 5 - определить собственно тип объекта, как наследника
от Concurrent.Object_Types.Object_Type и интерфейса,
определенного на шаге 1, определить методы Construct и
Freeze.

Шаг 6 - инстанциировать пакет All_In_One значениями,
полученными на шагах 2 - 5.

Шаг 7 - породить тип холдера (от
All_In_One.Singular_Holder_Type), подмешав интерфейс
объекта. Реализовать интерфейс как делегацию
внутр. объекту.

Шаг 8 - создать шаблон в каталоге

Шаг 9 - создать объект в хранилище

Шаг 10 - Создать видимость, указав в кач. дискриминанта
идентификатор объекта в хранилище.

@itemize

@item
one_object_and_view.adb -  Создание одиночного объекта и его первого вида.

@end itemize

@bye
>>>>>>> 1.1.2.3
